package app.accrescent.parcelo.validation

import com.android.apksig.ApkVerifier
import com.android.apksig.apk.ApkFormatException
import com.android.apksig.apk.ApkUtils
import com.android.apksig.util.DataSources
import com.android.bundle.Commands.BuildApksResult
import com.android.ide.common.xml.AndroidManifestParser
import com.android.io.IAbstractFile
import com.android.tools.apk.analyzer.BinaryXmlParser
import com.google.protobuf.InvalidProtocolBufferException
import io.ktor.util.moveToByteArray
import org.xml.sax.SAXException
import java.io.InputStream
import java.nio.ByteBuffer
import java.security.MessageDigest
import java.security.cert.X509Certificate
import java.util.zip.ZipInputStream

data class ApkSetMetadata(
    val appId: String,
    val versionCode: Int,
    val versionName: String,
    var bundletoolVersion: String,
)

const val ANDROID_MANIFEST = "AndroidManifest.xml"

/**
 * Parses an APK set into its metadata
 *
 * For now this function attempts to determine whether the APK set is valid on a best-effort
 * basis, so it may accept files which are not strictly valid APK sets. However, any APK set it
 * rejects is certainly invalid. It currently accepts the given file as a valid APK set according
 * to the following criteria:
 *
 * - the input file is a valid ZIP
 * - a valid APK is a ZIP with each of the following:
 *     - a v2 or v3 APK signature which passes verification and is generated by a non-debug
 *     certificate
 *     - a valid Android manifest at the expected path
 * - all non-directory entries in said ZIP except for "toc.pb" are valid APKs
 * - "toc.pb" is a valid BuildApksResult protocol buffer
 * - the input ZIP contains at least one APK
 * - all APKs have the same signing certificates
 * - all APKs have the same app ID and version code
 * - at least one APK specifies a version name
 *
 * @return metadata describing the APK set and the app it represents
 * @throws InvalidApkSetException the APK set is invalid
 */
fun parseApkSet(file: InputStream): ApkSetMetadata {
    var bundletoolVersion: String? = null
    var metadata: ApkSetMetadata? = null
    var pinnedCertHashes = emptyList<String>()

    ZipInputStream(file).use { zip ->
        generateSequence { zip.nextEntry }.filterNot { it.isDirectory }.forEach { entry ->
            val entryBytes = zip.readAllBytes()
            val entryDataSource = DataSources.asDataSource(ByteBuffer.wrap(entryBytes))

            // Parse metadata
            if (entry.name == "toc.pb") {
                val bundletoolMetadata = try {
                    BuildApksResult.newBuilder().mergeFrom(entryBytes).build()
                } catch (e: InvalidProtocolBufferException) {
                    throw InvalidApkSetException("bundletool metadata not valid")
                }
                bundletoolVersion = bundletoolMetadata.bundletool.version
                return@forEach
            }

            // Everything else is an APK. Start by finding and verifying its signature.
            val sigCheckResult = try {
                ApkVerifier.Builder(entryDataSource).build().verify()
            } catch (e: ApkFormatException) {
                throw InvalidApkSetException("an APK is malformed")
            }

            if (sigCheckResult.isVerified) {
                if (!(sigCheckResult.isVerifiedUsingV2Scheme || sigCheckResult.isVerifiedUsingV3Scheme)) {
                    throw InvalidApkSetException("APK signature isn't at least v2 or v3")
                } else if (sigCheckResult.signerCertificates.any { it.isDebug() }) {
                    throw InvalidApkSetException("APK signed with debug certificate")
                }
            } else {
                throw InvalidApkSetException("APK signature doesn't verify")
            }

            // Pin the APK signing certificates on the first APK encountered to ensure split APKs
            // can actually be installed.
            if (pinnedCertHashes.isEmpty()) {
                pinnedCertHashes = sigCheckResult.signerCertificates.map { it.fingerprint() }
            } else {
                // Check against pinned certificates
                val theseCertHashes = sigCheckResult.signerCertificates.map { it.fingerprint() }
                if (theseCertHashes != pinnedCertHashes) {
                    throw InvalidApkSetException("APK signing certificates don't match each other")
                }
            }

            // Parse the Android manifest
            val manifest = try {
                val manifestBytes = ApkUtils.getAndroidManifest(entryDataSource).moveToByteArray()
                BinaryXmlParser.decodeXml(ANDROID_MANIFEST, manifestBytes).inputStream()
                    .use { AndroidManifestParser.parse(it.toIAbstractFile(), true, null) }
            } catch (e: ApkFormatException) {
                throw InvalidApkSetException("an APK is malformed")
            } catch (e: SAXException) {
                throw InvalidApkSetException("invalid Android manifest")
            }

            // Pin the app metadata on the first manifest parsed to ensure all split APKs have the
            // same app ID and version code.
            //
            // Since the version name is only included in the base APK, we update it
            // opportunistically and freak out if it's still empty by the time we're done going
            // through all the APKs. There's no reason to pin it since it has no effect on
            // installation.
            if (metadata == null) {
                metadata = ApkSetMetadata(manifest.`package`, manifest.versionCode, "", "")
            } else {
                // Check that the metadata is the same as that previously pinned (sans the version
                // name for reasons described above).
                //
                // We can non-null assert the metadata here since the changing closure is called
                // sequentially.
                if (manifest.`package` != metadata!!.appId || manifest.versionCode != metadata!!.versionCode) {
                    throw InvalidApkSetException("APK manifest info is not consistent across all APKs")
                }

                // Update the version name if it exists (i.e., if this is the base APK)
                if (manifest.versionName != null) {
                    metadata = metadata!!.copy(versionName = manifest.versionName)
                }
            }
        }
    }

    if (bundletoolVersion != null) {
        metadata = metadata?.copy(bundletoolVersion = bundletoolVersion!!)
    } else {
        throw InvalidApkSetException("no bundletool version found")
    }

    // If nothing set the version name, freak out
    if (metadata?.versionName == "") {
        throw InvalidApkSetException("no APKs specified a version name")
    }

    return metadata ?: throw InvalidApkSetException("no APKs found")
}

/**
 * Returns whether this is a debug certificate generated by the Android SDK tools
 */
private fun X509Certificate.isDebug(): Boolean {
    return subjectX500Principal.name == "C=US,O=Android,CN=Android Debug"
}

/**
 * Gets the certificate's SHA256 fingerprint
 */
private fun X509Certificate.fingerprint(): String {
    return MessageDigest
        .getInstance("SHA-256")
        .digest(this.encoded)
        .joinToString("") { "%02x".format(it) }
}

/**
 * Hack utility method to convert an InputStream to an IAbstractFile
 *
 * This is a hack to satisfy the API contract of AndroidManifestParser.parse(), which requires an
 * IAbstractFile as a parameter. In reality, it uses none of that interface's methods besides
 * getContents() to get the underlying InputStream. Thus, we can convert an InputStream into an
 * IAbstractFile as long as we don't care that the rest of the interface isn't properly
 * implemented. Of course, this means that the IAbstractFile returned by this function shouldn't
 * be used for anything which _actually_ needs it, but only for that which needs the underlying
 * InputStream.
 */
private fun InputStream.toIAbstractFile(): IAbstractFile {
    val inputStream = this

    return object : IAbstractFile {
        override fun getOsLocation() = ""
        override fun exists() = true
        override fun getContents() = inputStream
        override fun setContents(source: InputStream) {}
        override fun getOutputStream() = null
    }
}

class InvalidApkSetException(message: String) : Exception(message)
